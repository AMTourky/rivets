<!DOCTYPE html><html><head><title>Rivets.js â€” Lightweight and powerful data binding + templating solution for building modern web applications</title><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/type.css"><link rel="stylesheet" href="/css/screen.css"><link rel="stylesheet" href="/css/syntax.css"><link rel="stylesheet" href="/css/responsive.css"><script src="/js/jquery.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/highlight.js"></script><meta name="viewport" content="width=device-width, initial-scale=1.0"><script>hljs.initHighlightingOnLoad();

var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-6079274-2']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script></head><body data-spy="scroll" data-target="#nav"><header><div class="container"><div class="col col-md-7"><h1 class="brand-heading">Rivets.js</h1><p class="blurb">Lightweight and powerful data binding + templating solution for building modern web applications.</p><a href="/dist/rivets.min.js" class="btn btn-clear"><i>&#128229;</i><span>Download 0.5.10</span></a><a href="http://github.com/mikeric/rivets" class="btn btn-clear"><i class="social">&#62208;</i><span>GitHub Repository</span></a><a href="/docs/rivets.html" class="btn btn-clear"><i>&#59156;</i><span>Annotated Source</span></a></div><div class="col col-md-5 graphic hidden-sm hidden-xs"><img src="/img/rv-blueprints.png"></div></div></header><div class="container"><p>Rivets.js is agnostic about the objects that it can subscribe to. This makes it very flexible as it can adapt to work with virtually any library or framework, but it also means that you need to tell Rivets.js <em>how</em> to subscribe to those objects. This is where adapters come in to play.</p>
<p>Each adapter is defined to a unique interface (a single character) which is used to separate the keys in a keypath. The interfaces used in a keypath determine which adapter to use for each intermediary key.</p>
<pre><code>user.address:city</code></pre>
<p>The above keypath will use the <code>.</code> adapter to access the <code>address</code> key on the <code>user</code> object, and the <code>:</code> adapter to access the <code>city</code> key on the <code>address</code> object. If you can imagine for a second that <code>address</code> is just a normal property on the user object pointing to a Backbone model, but <code>city</code> is actually an attribute on that Backbone model, you can see how this kind of notation is actually very succint and expressive.</p>
</div></body></html>