<h3>Formatters</h3>

<p>Formatters are functions that mutate the incoming and/or outgoing value of a binding. You can use them to format dates, numbers, currencies, etc. and because they work in a similar fashion to the Unix pipeline, the output of each feeds directly as input to the next one, so you can stack as many of them together as you like.</p>

<h4>One-Way Formatters</h4>

<p>This is by far the most common and practical way to use formatters --- simple read-only mutations to a value. Taking the dates example from above, we can define a `date` formatter that returns a human-friendly version of a date value.</p>

<pre><code>
rivets.formatters.date = function(value){
  return moment(value).format('MMM DD, YYYY')
}
</code></pre>

<p>Formatters are applied by piping them to binding declarations using `|` as a delimiter.</p>

<pre><code>
<span data-text="event.startDate | date"></span>
</code></pre>

<h4>Two-Way Formatters</h4>

<p>Two-way formatters are useful when you want to store a value in a particular format, such as a unix epoch time or a cent value, but still let the user input the value in a different format.</p>

<p>Instead of defining the formatter as a single function, you define it as an object containing `read` and `publish` functions. When a formatter is defined as a single function, Rivets assumes it to be in the read direction only. When defined as an object, Rivets uses it's `read` and `publish` functions to effectively serialize and de-serialize the value.</p>

<p>Using the cent value example from above, let's say we want to store a monetary value as cents but let the user input it in a dollar amount. For this we can define a two-way `currency` formatter imlemented below.</p>

<pre><code>
rivets.formatters.currency = {
  read: function(value) {
    return (value / Math.pow(10, n)).toFixed(2)
  },
  publish: function(value) {
    return Math.round(parseFloat(value) * Math.pow(10, 2))
  }
}
</code></pre>

<p>Note that you can also chain bidirectional formatters with any other formatters, and in any order. They read from left to right, and publish from right to left, skipping any read-only formatters when publishing the value back to the model.</p>

<h4>Formatter Arguments</h4>

<p>Need to pass arguments to your formatter? Not a problem.</p>

<pre><code>
<span data-text="billing.cardNumber | mask 4 4 ********"></span>
</code></pre>

<p>Note that all arguments are passed in as strings, so you will need to do your own type conversions to primitives if necessary.</p>

<pre><code>
rivets.formatters.mask = function(value, left, right, mask) {
  formatted = value.substring(0, left)
  formatted + mask
  formatted += value.substring(value.length - right)

  return formatted
}
</code></pre>
